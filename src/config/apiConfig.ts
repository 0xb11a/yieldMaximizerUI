import { POOL_ADDRESSES, RESERVE_ADDRESSES, PoolAddress, ReserveAddress } from './poolsAndReserves';

/**
 * Represents a lending reserve with its key parameters
 * Used for calculating interest rates and managing liquidity
 */
export interface Reserve {
  name: string;
  total_borrowed: number;
  total_supplied: number;
  optimal_usage_ratio: number;
  variable_rate_slope1: number;
  variable_rate_slope2: number;
  token_price: number;
  fee_percentage: number;
  base_variable_borrow_rate: number;
  reserve_factor?: number; // Optional: Reserve factor (added)
}

/**
 * Represents a liquidity pool on a specific blockchain
 */
export interface Pool {
  name: string;     // Name of the pool
  daily_fee?: number; // Optional: Daily fee generated by the pool
  pool_distribution?: number; // Optional: Pool's distribution amount
  protocol_fee?: number; // Optional: Protocol fee percentage
  reward_per_day?: number; // Optional: Daily rewards distributed
  reward_token_price?: number; // Optional: Price of the reward token
}

/**
 * Structure for the /calculate-optimal-allocation API request payload
 */
export interface AllocationRequestBody {
  total_funds: number;
  pools: Pool[];
  reserves: Reserve[];
  min_allocation_percent?: number; // Optional minimum allocation percentage
}

/**
 * API response detail item structure for /calculate-optimal-allocation
 */
interface AllocationResponseDetail {
  allocated_amount: number;
  base_apr?: number;
  base_apy: number; // Non-reward APY
  expected_profit: number;
  name: string; // Name is now provided directly
  percentage: number;
  rewards_apr?: number;
  rewards_apy: number; // Reward APY
  total_apr?: number;
  total_apy: number; // Total APY
  type: 'pool' | 'reserve';
}

/**
 * Raw API response structure for /calculate-optimal-allocation
 */
interface AllocationResponseBody {
  details: AllocationResponseDetail[];
  total_profit: number;
  // Optional index-based supply fields from example
  pool1_supply?: number;
  reserve2_supply?: number;
  reserve3_supply?: number;
  // Consider adding index signature if more dynamic fields exist: [key: string]: any;
}

/**
 * Processed API response for frontend use
 */
export interface ApiResponse {
  investments: Investment[];      // Individual allocations
  total_profit: number;          // Expected total profit
  total_expected_return: number; // Overall expected APY (calculated from total_profit / total_funds)
  total_funds: number;           // Total amount distributed
}

/**
 * Represents a single investment allocation (updated)
 */
export interface Investment {
  name: string;
  allocation: number;
  expected_return: number; // Mapped from total_apy
  expectedProfit: number;
  reserve_apy?: number;   // Mapped from base_apy
  rewards_apy?: number;   // Mapped from rewards_apy
  total_apr?: number;
  base_apr?: number;      // Added: Mapped from base_apr
  rewards_apr?: number;   // Added: Mapped from rewards_apr
  type: 'pool' | 'reserve';
}

// Added interfaces for /fetch-pool-data endpoint
interface FetchDataRequestBody {
  wallet_address: string;
  funds: (PoolAddress | ReserveAddress)[];
}

interface FetchDataResponseBody {
  pools: Pool[];
  reserves: Reserve[];
}

// Added function to fetch pool and reserve data
export async function fetchPoolAndReserveData(walletAddress: string): Promise<FetchDataResponseBody> {
  if (!process.env.NEXT_PUBLIC_API_URL) {
    throw new Error('API URL is not configured');
  }
  const apiUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/fetch-pool-data`;

  const funds = [...POOL_ADDRESSES, ...RESERVE_ADDRESSES];
  const requestBody: FetchDataRequestBody = {
    wallet_address: walletAddress,
    funds: funds
  };

  console.log('Fetching pool/reserve data with body:', requestBody);

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'No error details available');
      logger.error('API Response Error (fetch-pool-data)', {
         url: apiUrl,
        status: response.status,
        statusText: response.statusText,
         errorBody: errorText
      });
      throw new Error(`API error fetching pool/reserve data: ${response.status} ${response.statusText}`);
    }

    const data: FetchDataResponseBody = await response.json();
    console.log('Pool/reserve data received:', data);
    // Add validation here if needed
    return data;
  } catch (error) {
    console.error('Fetch pool/reserve data error:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to fetch pool/reserve data: ${error.message}`);
    }
    throw new Error('Failed to fetch pool/reserve data');
  }
}

/**
 * Generates the request body for the allocation API
 * @param reserves - Array of available lending reserves
 * @param totalFunds - Total amount to be distributed
 * @param pools - Array of available liquidity pools
 * @param minAllocationPercent - Optional minimum allocation percentage for each asset
 * @returns Formatted request body for /calculate-optimal-allocation API
 */
export function generateAllocationRequestBody(
  reserves: Reserve[],
  totalFunds: number,
  pools: Pool[],
  minAllocationPercent?: number
): AllocationRequestBody {
  const body: AllocationRequestBody = {
    total_funds: totalFunds,
    pools: pools,
    reserves: reserves,
  };
  if (minAllocationPercent !== undefined) {
    body.min_allocation_percent = minAllocationPercent;
  }
  return body;
}

/**
 * Fetches optimal allocation from the /calculate-optimal-allocation API (updated)
 */
export async function fetchOptimalAllocation(
  totalFunds: number,
  pools: Pool[],
  reserves: Reserve[],
  minAllocationPercent?: number
): Promise<ApiResponse> {
  try {
    // Generate the request body using the new function
    const requestBody = generateAllocationRequestBody(reserves, totalFunds, pools, minAllocationPercent);

    if (!process.env.NEXT_PUBLIC_API_URL) {
      throw new Error('API URL is not configured');
    }
    const allocationApiUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/calculate-optimal-allocation`;

    const response = await fetch(allocationApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'No error details available');
      logger.error('API Response Error (calculate-optimal-allocation)', {
         url: allocationApiUrl,
        status: response.status,
        statusText: response.statusText,
         errorBody: errorText
      });
      throw new Error(`API error calculating optimal allocation: ${response.status} ${response.statusText}`);
    }

    const data: AllocationResponseBody = await response.json();
    console.log('Calculate optimal allocation server response:', data);

    // Transform API response (updated mapping)
    const transformedData: ApiResponse = {
      investments: data.details.map(item => ({
        name: item.name,
        allocation: item.allocated_amount,
        expected_return: item.total_apy,
        expectedProfit: item.expected_profit,
        reserve_apy: item.base_apy,
        rewards_apy: item.rewards_apy,
        total_apr: item.total_apr,
        base_apr: item.base_apr,         // Added mapping for base_apr
        rewards_apr: item.rewards_apr,   // Added mapping for rewards_apr
        type: item.type
      })),
      total_profit: data.total_profit,
      total_expected_return: totalFunds > 0 ? data.total_profit / totalFunds : 0,
      total_funds: totalFunds
    };

    return transformedData;
  } catch (error) {
    console.error('Fetch optimal allocation error:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to fetch optimal allocation: ${error.message}`);
    }
    throw new Error('Failed to fetch optimal allocation');
  }
} 
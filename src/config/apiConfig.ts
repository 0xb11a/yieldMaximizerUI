import { getAssetsForApi, SUPPORTED_ASSETS } from './assets';
import logger from '@/utils/logger';
import { Address } from 'viem';

/**
 * Represents a lending reserve with its key parameters
 * Used for calculating interest rates and managing liquidity
 */
export interface Reserve {
  name: string; // API Name (e.g., "USDC Reserve") - Matched against AssetConfig.apiName
  address?: Address; // Optional address returned by API
  total_borrowed: number;
  total_supplied: number;
  optimal_usage_ratio: number;
  variable_rate_slope1: number;
  variable_rate_slope2: number;
  token_price: number;
  fee_percentage: number;
  base_variable_borrow_rate: number;
  reserve_factor?: number; // Optional: Reserve factor (added)
  base_apy?: number; // Optional: Base APY returned by fetch-pool-data
  rewards_apy?: number; // Optional: Rewards APY returned by fetch-pool-data
  source?: string; // Optional: Source identifier (e.g., "Lendle Mantle") - Matched against AssetConfig.source
}

/**
 * Represents a liquidity pool on a specific blockchain
 */
export interface Pool {
  name: string;     // API Name (e.g., "USDC-USDT") - Matched against AssetConfig.apiName
  address?: Address; // Optional address returned by API
  daily_fee?: number; // Optional: Daily fee generated by the pool
  pool_distribution?: number; // Optional: Pool's distribution amount
  protocol_fee?: number; // Optional: Protocol fee percentage
  reward_per_day?: number; // Optional: Daily rewards distributed
  reward_token_price?: number; // Optional: Price of the reward token
  base_apy?: number; // Optional: Base APY returned by fetch-pool-data
  rewards_apy?: number; // Optional: Rewards APY returned by fetch-pool-data
  token_price?: number; // Optional: Price of the LP token returned by fetch-pool-data
  source?: string; // Optional: Source identifier (e.g., "Merchant Moe Mantle") - Matched against AssetConfig.source
}

/**
 * Structure for the /calculate-optimal-allocation API request payload
 */
export interface AllocationRequestBody {
  total_funds: number;
  pools: Pool[];
  reserves: Reserve[];
  min_allocation_percent?: number; // Optional minimum allocation percentage
}

/**
 * API response detail item structure for /calculate-optimal-allocation
 */
interface AllocationResponseDetail {
  allocated_amount: number;
  base_apr?: number;
  base_apy: number; // Non-reward APY
  expected_profit: number;
  name: string; // Name is now provided directly
  percentage: number;
  rewards_apr?: number;
  rewards_apy: number; // Reward APY
  total_apr?: number;
  total_apy: number; // Total APY
  type: 'pool' | 'reserve';
}

/**
 * Raw API response structure for /calculate-optimal-allocation
 */
interface AllocationResponseBody {
  details: AllocationResponseDetail[];
  total_profit: number;
  // Optional index-based supply fields from example
  pool1_supply?: number;
  reserve2_supply?: number;
  reserve3_supply?: number;
  // Consider adding index signature if more dynamic fields exist: [key: string]: any;
}

/**
 * Processed API response for frontend use
 */
export interface ApiResponse {
  investments: Investment[];      // Individual allocations
  total_profit: number;          // Expected total profit
  total_expected_return: number; // Overall expected APY (calculated from total_profit / total_funds)
  total_funds: number;           // Total amount distributed
}

/**
 * Represents a single investment allocation (updated)
 */
export interface Investment {
  name: string;
  allocation: number;
  expected_return: number; // Mapped from total_apy
  expectedProfit: number;
  reserve_apy?: number;   // Mapped from base_apy
  rewards_apy?: number;   // Mapped from rewards_apy
  total_apr?: number;
  base_apr?: number;      // Added: Mapped from base_apr
  rewards_apr?: number;   // Added: Mapped from rewards_apr
  type: 'pool' | 'reserve';
  percentage?: number; 
}

// Added interfaces for /fetch-pool-data endpoint
interface FetchDataRequestBody {
  wallet_address: string;
  funds: { type: 'pool' | 'reserve'; address: Address; source?: string }[];
}

interface FetchDataResponseBody {
  pools: Pool[];
  reserves: Reserve[];
}

// Added function to fetch pool and reserve data
export async function fetchPoolAndReserveData(walletAddress: string): Promise<FetchDataResponseBody> {
  if (!process.env.NEXT_PUBLIC_API_URL) {
    throw new Error('API URL is not configured');
  }
  const apiUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/fetch-pool-data`;

  const funds = getAssetsForApi();
  const requestBody: FetchDataRequestBody = {
    wallet_address: walletAddress,
    funds: funds
  };

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    const responseText = await response.text(); // Get text first for logging

    if (!response.ok) {
      logger.error('API Response Error (fetch-pool-data)', {
         url: apiUrl,
        status: response.status,
        statusText: response.statusText,
         errorBody: responseText
      });
      throw new Error(`API error fetching pool/reserve data: ${response.status} ${response.statusText}`);
    }

    let data: FetchDataResponseBody;
    try {
      data = JSON.parse(responseText);
    } catch (parseError) {
        console.error('Failed to parse JSON from /fetch-pool-data:', parseError);
        throw new Error('Failed to parse server response from /fetch-pool-data.');
    }
    
    // --- Revert: Removed custom mapping based on request order --- 

    // --- Optional: Restore simple address mapping if needed, or just return --- 
    // Example: Map contractAddress back if API doesn't return it consistently 
    // (Adjust this part based on what's actually needed)
    data.pools = data.pools.map(pool => {
       const config = SUPPORTED_ASSETS.find(a => 
         (pool.address && a.contractAddress.toLowerCase() === pool.address.toLowerCase() && a.apiType === 'pool') || 
         (a.name.includes(pool.name) && a.apiType === 'pool') 
       );
       return { ...pool, address: pool.address ?? config?.contractAddress };
    });
    data.reserves = data.reserves.map(reserve => {
       const config = SUPPORTED_ASSETS.find(a => 
         (reserve.address && a.contractAddress.toLowerCase() === reserve.address.toLowerCase() && a.apiType === 'reserve') ||
         (a.apiType === 'reserve' && a.apiName === reserve.name)
       );
       return { ...reserve, address: reserve.address ?? config?.contractAddress };
    });
    // --- End Optional Mapping --- 

    return data;
  } catch (error) {
    console.error('Fetch pool/reserve data error:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to fetch pool/reserve data: ${error.message}`);
    }
    throw new Error('Failed to fetch pool/reserve data');
  }
}

// Helper function to format numbers to a max of 4 decimal places
const formatNumberToMaxFourDecimals = (num: number | undefined | null): number => {
  if (num === undefined || num === null || isNaN(num)) {
    return 0; // Or handle as an error, or return undefined/null based on desired behavior
  }
  return parseFloat(num.toFixed(4));
};

/**
 * Generates the request body for the allocation API
 * @param reserves - Array of available lending reserves
 * @param totalFunds - Total amount to be distributed
 * @param pools - Array of available liquidity pools
 * @param minAllocationPercent - Optional minimum allocation percentage for each asset
 * @returns Formatted request body for /calculate-optimal-allocation API
 */
export function generateAllocationRequestBody(
  reserves: Reserve[],
  totalFunds: number,
  pools: Pool[],
  minAllocationPercent?: number
): AllocationRequestBody {
  // Helper to format all numeric values in an object
  const formatObjectNumbers = <T extends Record<string, unknown>>(obj: T): T => {
    const newObj: Record<string, unknown> = {};
    for (const key in obj) {
      if (typeof obj[key] === 'number') {
        newObj[key] = formatNumberToMaxFourDecimals(obj[key] as number);
      } else {
        newObj[key] = obj[key];
      }
    }
    return newObj as T;
  };

  // Remove address field and format numbers before sending to API
  const poolsFormatted = pools.map((poolItem: Pool) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { address: _unusedAddress, ...rest } = poolItem;
    return formatObjectNumbers(rest); 
  });
  const reservesFormatted = reserves.map((reserveItem: Reserve) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { address: _unusedAddress, ...rest } = reserveItem;
    return formatObjectNumbers(rest);
  });

  const body: AllocationRequestBody = {
    total_funds: formatNumberToMaxFourDecimals(totalFunds),
    pools: poolsFormatted,     // Use formatted arrays
    reserves: reservesFormatted, // Use formatted arrays
  };
  if (minAllocationPercent !== undefined) {
    body.min_allocation_percent = formatNumberToMaxFourDecimals(minAllocationPercent);
  }
  return body;
}

/**
 * Fetches optimal allocation from the /calculate-optimal-allocation API (updated)
 */
export async function fetchOptimalAllocation(
  totalFunds: number,
  pools: Pool[], 
  reserves: Reserve[], 
  minAllocationPercent?: number
): Promise<ApiResponse> {
  try {
    const requestBody = generateAllocationRequestBody(reserves, totalFunds, pools, minAllocationPercent);

    if (!process.env.NEXT_PUBLIC_API_URL) {
      throw new Error('API URL is not configured');
    }
    const allocationApiUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/calculate-optimal-allocation`;

    const response = await fetch(allocationApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    const responseText = await response.text(); // Get text first

    if (!response.ok) {
      logger.error('API Response Error (calculate-optimal-allocation)', {
         url: allocationApiUrl,
        status: response.status,
        statusText: response.statusText,
         errorBody: responseText
      });
      throw new Error(`API error calculating optimal allocation: ${response.status} ${response.statusText}`);
    }

    // --- Handle non-standard JSON values like Infinity --- 
    let sanitizedText = responseText;
    let data: AllocationResponseBody;
    try {
        sanitizedText = responseText.replace(/Infinity/g, 'null').replace(/-Infinity/g, 'null');
        data = JSON.parse(sanitizedText);
        // --- End Handling ---

        // Transform API response (updated mapping)
        const transformedData: ApiResponse = {
          investments: data.details.map(item => ({
            name: item.name,
            allocation: item.allocated_amount,
            // Use APY values directly as percentages
            expected_return: item.total_apy ?? 0, 
            expectedProfit: item.expected_profit,
            reserve_apy: item.base_apy ?? 0,   
            rewards_apy: item.rewards_apy ?? 0, 
            // Map APY to APR fields directly (assuming API doesn't provide separate APR)
            total_apr: item.total_apy ?? 0,     
            base_apr: item.base_apy ?? 0,      
            rewards_apr: item.rewards_apy ?? 0, 
            type: item.type,
            percentage: item.percentage === null ? 0 : item.percentage
          })),
          total_profit: data.total_profit,
          // Use sanitized totalFunds if needed, or ensure it's not 0 before division
          total_expected_return: totalFunds > 0 ? (data.total_profit / totalFunds) * 100 : 0, // Calculate as percentage
          total_funds: totalFunds
        };

        return transformedData;
    } catch (parseError) {
        console.error('Failed to parse sanitized JSON response:', parseError);
        console.error('Original text:', responseText);
        console.error('Sanitized text:', sanitizedText);
        throw new Error('Failed to parse server response after sanitization.');
    }

  } catch (error) {
    console.error('Fetch optimal allocation error:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to fetch optimal allocation: ${error.message}`);
    }
    throw new Error('Failed to fetch optimal allocation');
  }
}

/**
 * Represents a single token/position returned by the portfolio API
 */
export interface PortfolioToken {
  id: string; // Token address or native identifier (e.g., 'mnt')
  name: string;
  decimals: number;
  amount: number; // Raw token amount
  amountUsd: number; // Value in USD
  priceUsd: number;
  chain: string; // e.g., 'mnt'
  logoUrl: string;
  protocol?: string; // e.g., 'INIT Capital', 'lendle.xyz', 'Merchant Moe'
  type?: 'Supply' | string; // e.g., 'Supply' for positions
  group?: 'Lending' | 'Liquidity Pool' | string; // e.g., 'Lending', 'Liquidity Pool'
  poolId?: string; // Identifier for the specific pool/reserve within the protocol
}

/**
 * Represents the main response structure of the portfolio API
 */
export interface PortfolioApiResponse {
  address: Address;
  type: string | null; // Can be 'EOA' or null
  protocol: string; // e.g., 'EVM'
  lastSyncAt: string | null;
  tokens: PortfolioToken[];
  total: number; // Total portfolio value in USD
}

/**
 * Fetches portfolio data from the public API
 * @param walletAddress The user's wallet address
 * @param chainId The chain ID (e.g., 5000 for Mantle)
 * @returns The parsed portfolio data
 */
export async function fetchPortfolioData(walletAddress: Address, chainId?: number): Promise<PortfolioApiResponse> {
  // Use a base URL from environment variables if available, otherwise fallback
  const baseApiUrl = process.env.NEXT_PUBLIC_PORTFOLIO_API_URL || 'https://api.b11a.xyz/api/v1/public';
  
  let apiUrl = `${baseApiUrl}/portfolio/${walletAddress}/yield`;
  if (chainId !== undefined) {
    apiUrl += `?chainId=${chainId}`;
  }

  logger.info('Fetching portfolio data', { url: apiUrl });

  try {
    const response = await fetch(apiUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
    });

    const responseText = await response.text(); // Get text first for logging

    if (!response.ok) {
      logger.error('API Response Error (fetchPortfolioData)', {
        url: apiUrl,
        status: response.status,
        statusText: response.statusText,
        errorBody: responseText
      });
      // Provide a more user-friendly error based on status
      if (response.status === 404) {
         throw new Error(`Portfolio data not found for address ${walletAddress} on chain ${chainId}.`);
      } else if (response.status >= 500) {
         throw new Error(`Server error (${response.status}) when fetching portfolio data. Please try again later.`);
      } else {
         throw new Error(`API error fetching portfolio data: ${response.status} ${response.statusText}`);
      }
    }

    let data: PortfolioApiResponse;
    try {
      data = JSON.parse(responseText);
    } catch (parseError) {
      logger.error('Failed to parse JSON from /portfolio', { error: parseError, responseText });
      throw new Error('Failed to parse server response from portfolio API.');
    }

    logger.info('Successfully fetched portfolio data', { address: walletAddress, tokenCount: data.tokens.length, totalValue: data.total });
    return data;

  } catch (error) {
    logger.error('Fetch portfolio data error', { error });
    // Re-throw specific error messages or a generic one
    if (error instanceof Error) {
      throw new Error(`Failed to fetch portfolio data: ${error.message}`);
    }
    throw new Error('An unknown error occurred while fetching portfolio data.');
  }
} 
import { getAssetsForApi, SUPPORTED_ASSETS } from './assets';
import logger from '@/utils/logger';
import { Address } from 'viem';

/**
 * Represents a lending reserve with its key parameters
 * Used for calculating interest rates and managing liquidity
 */
export interface Reserve {
  name: string;
  address?: Address;
  total_borrowed: number;
  total_supplied: number;
  optimal_usage_ratio: number;
  variable_rate_slope1: number;
  variable_rate_slope2: number;
  token_price: number;
  fee_percentage: number;
  base_variable_borrow_rate: number;
  reserve_factor?: number; // Optional: Reserve factor (added)
  base_apy?: number; // Optional: Base APY returned by fetch-pool-data
  rewards_apy?: number; // Optional: Rewards APY returned by fetch-pool-data
  source?: string; // Optional: Source of the reserve
}

/**
 * Represents a liquidity pool on a specific blockchain
 */
export interface Pool {
  name: string;     // Name of the pool
  address?: Address;
  daily_fee?: number; // Optional: Daily fee generated by the pool
  pool_distribution?: number; // Optional: Pool's distribution amount
  protocol_fee?: number; // Optional: Protocol fee percentage
  reward_per_day?: number; // Optional: Daily rewards distributed
  reward_token_price?: number; // Optional: Price of the reward token
  base_apy?: number; // Optional: Base APY returned by fetch-pool-data
  rewards_apy?: number; // Optional: Rewards APY returned by fetch-pool-data
  token_price?: number; // Optional: Price of the LP token returned by fetch-pool-data
  source?: string; // Optional: Source of the pool
}

/**
 * Structure for the /calculate-optimal-allocation API request payload
 */
export interface AllocationRequestBody {
  total_funds: number;
  pools: Pool[];
  reserves: Reserve[];
  min_allocation_percent?: number; // Optional minimum allocation percentage
}

/**
 * API response detail item structure for /calculate-optimal-allocation
 */
interface AllocationResponseDetail {
  allocated_amount: number;
  base_apr?: number;
  base_apy: number; // Non-reward APY
  expected_profit: number;
  name: string; // Name is now provided directly
  percentage: number;
  rewards_apr?: number;
  rewards_apy: number; // Reward APY
  total_apr?: number;
  total_apy: number; // Total APY
  type: 'pool' | 'reserve';
}

/**
 * Raw API response structure for /calculate-optimal-allocation
 */
interface AllocationResponseBody {
  details: AllocationResponseDetail[];
  total_profit: number;
  // Optional index-based supply fields from example
  pool1_supply?: number;
  reserve2_supply?: number;
  reserve3_supply?: number;
  // Consider adding index signature if more dynamic fields exist: [key: string]: any;
}

/**
 * Processed API response for frontend use
 */
export interface ApiResponse {
  investments: Investment[];      // Individual allocations
  total_profit: number;          // Expected total profit
  total_expected_return: number; // Overall expected APY (calculated from total_profit / total_funds)
  total_funds: number;           // Total amount distributed
}

/**
 * Represents a single investment allocation (updated)
 */
export interface Investment {
  name: string;
  allocation: number;
  expected_return: number; // Mapped from total_apy
  expectedProfit: number;
  reserve_apy?: number;   // Mapped from base_apy
  rewards_apy?: number;   // Mapped from rewards_apy
  total_apr?: number;
  base_apr?: number;      // Added: Mapped from base_apr
  rewards_apr?: number;   // Added: Mapped from rewards_apr
  type: 'pool' | 'reserve';
}

// Added interfaces for /fetch-pool-data endpoint
interface FetchDataRequestBody {
  wallet_address: string;
  funds: { type: 'pool' | 'reserve'; address: Address; source?: string }[];
}

interface FetchDataResponseBody {
  pools: Pool[];
  reserves: Reserve[];
}

// Added function to fetch pool and reserve data
export async function fetchPoolAndReserveData(walletAddress: string): Promise<FetchDataResponseBody> {
  if (!process.env.NEXT_PUBLIC_API_URL) {
    throw new Error('API URL is not configured');
  }
  const apiUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/fetch-pool-data`;

  const funds = getAssetsForApi();
  const requestBody: FetchDataRequestBody = {
    wallet_address: walletAddress,
    funds: funds
  };

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    const responseText = await response.text(); // Get text first for logging

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'No error details available');
      logger.error('API Response Error (fetch-pool-data)', {
         url: apiUrl,
        status: response.status,
        statusText: response.statusText,
         errorBody: errorText
      });
      throw new Error(`API error fetching pool/reserve data: ${response.status} ${response.statusText}`);
    }

    let data: FetchDataResponseBody;
    try {
      data = JSON.parse(responseText);
    } catch (parseError) {
        console.error('Failed to parse JSON from /fetch-pool-data:', parseError);
        throw new Error('Failed to parse server response from /fetch-pool-data.');
    }
    
    // --- Revert: Removed custom mapping based on request order --- 

    // --- Optional: Restore simple address mapping if needed, or just return --- 
    // Example: Map contractAddress back if API doesn't return it consistently 
    // (Adjust this part based on what's actually needed)
    data.pools = data.pools.map(pool => {
       const config = SUPPORTED_ASSETS.find(a => a.name.includes(pool.name) && a.apiType === 'pool'); // Example: Less precise name match
       return { ...pool, address: config?.contractAddress }; 
    });
    data.reserves = data.reserves.map(reserve => {
       const config = SUPPORTED_ASSETS.find(a => a.underlyingTokens[0]?.symbol === reserve.name && a.apiType === 'reserve');
       return { ...reserve, address: config?.contractAddress }; 
    });
    // --- End Optional Mapping --- 

    return data;
  } catch (error) {
    console.error('Fetch pool/reserve data error:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to fetch pool/reserve data: ${error.message}`);
    }
    throw new Error('Failed to fetch pool/reserve data');
  }
}

/**
 * Generates the request body for the allocation API
 * @param reserves - Array of available lending reserves
 * @param totalFunds - Total amount to be distributed
 * @param pools - Array of available liquidity pools
 * @param minAllocationPercent - Optional minimum allocation percentage for each asset
 * @returns Formatted request body for /calculate-optimal-allocation API
 */
export function generateAllocationRequestBody(
  reserves: Reserve[],
  totalFunds: number,
  pools: Pool[],
  minAllocationPercent?: number
): AllocationRequestBody {
  const body: AllocationRequestBody = {
    total_funds: totalFunds,
    pools: pools,
    reserves: reserves,
  };
  if (minAllocationPercent !== undefined) {
    body.min_allocation_percent = minAllocationPercent;
  }
  return body;
}

/**
 * Fetches optimal allocation from the /calculate-optimal-allocation API (updated)
 */
export async function fetchOptimalAllocation(
  totalFunds: number,
  pools: Pool[], 
  reserves: Reserve[], 
  minAllocationPercent?: number
): Promise<ApiResponse> {
  try {
    const requestBody = generateAllocationRequestBody(reserves, totalFunds, pools, minAllocationPercent);

    if (!process.env.NEXT_PUBLIC_API_URL) {
      throw new Error('API URL is not configured');
    }
    const allocationApiUrl = `${process.env.NEXT_PUBLIC_API_URL}/api/calculate-optimal-allocation`;

    const response = await fetch(allocationApiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    const responseText = await response.text(); // Get text first

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'No error details available');
      logger.error('API Response Error (calculate-optimal-allocation)', {
         url: allocationApiUrl,
        status: response.status,
        statusText: response.statusText,
         errorBody: errorText
      });
      throw new Error(`API error calculating optimal allocation: ${response.status} ${response.statusText}`);
    }

    // --- Handle non-standard JSON values like Infinity --- 
    let sanitizedText = responseText;
    let data: AllocationResponseBody;
    try {
        sanitizedText = responseText.replace(/Infinity/g, 'null').replace(/-Infinity/g, 'null');
        data = JSON.parse(sanitizedText);
        // --- End Handling ---

        // Transform API response (updated mapping)
        const transformedData: ApiResponse = {
          investments: data.details.map(item => ({
            name: item.name,
            allocation: item.allocated_amount,
            expected_return: item.total_apy,
            expectedProfit: item.expected_profit,
            reserve_apy: item.base_apy,
            rewards_apy: item.rewards_apy,
            total_apr: item.total_apr,
            base_apr: item.base_apr,         
            rewards_apr: item.rewards_apr,   
            type: item.type,
            // Handle null percentage after sanitization
            percentage: item.percentage === null ? 0 : item.percentage // Set percentage to 0 if it was Infinity
          })),
          total_profit: data.total_profit,
          // Use sanitized totalFunds if needed, or ensure it's not 0 before division
          total_expected_return: totalFunds > 0 ? (data.total_profit / totalFunds) * 100 : 0, // Calculate as percentage
          total_funds: totalFunds
        };

        return transformedData;
    } catch (parseError) {
        console.error('Failed to parse sanitized JSON response:', parseError);
        console.error('Original text:', responseText);
        console.error('Sanitized text:', sanitizedText);
        throw new Error('Failed to parse server response after sanitization.');
    }

  } catch (error) {
    console.error('Fetch optimal allocation error:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to fetch optimal allocation: ${error.message}`);
    }
    throw new Error('Failed to fetch optimal allocation');
  }
} 